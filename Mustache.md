在众多模板引擎中，`Mustache` 可能是最有群众基础的，我们简单罗列几个它的家族成员：

* [Mustache](http://mustache.github.io/)
* [Hogan](http://twitter.github.io/hogan.js/)
* [Handlebars](http://handlebarsjs.com)

有这么多热衷于 `Mustache` 的轮子，可见其基因的优秀。

知乎上有一篇帖子 [Mustache 比传统的模板语言好在哪些地方？](https://www.zhihu.com/question/19882912)其中提的最多的一个关键词是“**简单**”。

是的，模板应该简单。模板引擎代表之一的 `Smarty` 堪称拥有非常强大的功能，可结果呢，模板却经常出现各种不可维护的代码，由此可见，再强大的模板引擎也无法很好的处理复杂的业务逻辑。

组件化带来了一种全新的开发思想，它主张把可控的复杂度分布到各个组件中，最后再把这些组件拼成一个页面。虽然整体的业务复杂度没有降低，代码质量却上了一个台阶，由此前端进入了新的时代。

简单是我们选择 `Mustache` 的原因，但我们不满足于此，我们希望让它更简单一些，下面将介绍 Yox 版本的 Mustache 语法。

## 定界符

Mustache 的默认定界符是 `{{` 和 `}}`，我们认为这个设计非常好。

和很多框架不同的是，我们不支持自定义定界符，没有理由不选择最好的设计。

## 插值

定界符之间的内容通常是一个可求值的**表达式**，它的值最终会经过**转义**再渲染出来，因此它是**安全**的。

一般来说，表达式可以是一个变量，如下：

```
{{name}}
```

或者是对象的属性、数组的下标，如下：

```
{{object.prop}}
{{array[0]}}
```

或者是稍微复杂一些的表达式，如下：

```
{{name ? '你好' : '请登录'}}
```

## 不转义插值

插值的**非安全**版本，即渲染的内容和表达式的值完全一致，不做转义处理，常用于富文本的展示。

```
{{{expression}}}
```

## 注释

```html
{{!注释}}
```

## 条件判断

`if` 或 `else if` 后面跟一个表达式，概念和 js 完全一致。

在 Mustache 的原版语法中，空数组会被认为是 `false`，这个设计严重违背工程师的第一直觉，因此我们把它剔除了。

```
{{#if expression}}
    ...
{{else if expression}}
    ...
{{/if}}
```

如果对 `else if` 这种带空格的默认配置不满意，可以自行修改配置，比如 `{{elseif expression}}` 或者 `{{elif expression}}`。

## 循环数组

循环通常有两种设计风格，一种是 `item in array`，一种是 `each`。

我更偏向 `each`，因为它可以省略 `item`，减少命名的脑力消耗。

```
{{#each array}}
    ...
{{/each}}
```

有别于前面介绍的语法，`each` 会导致 context 递进一层，举个例子：

数据

```javascript
{
    list: [
        {
            name: 'Jake',
            age: 1
        },
        {
            name: 'John',
            age: 2
        }
    ]
}
```

模板

```html
{{#each list}}
    {{name}}: {{age}}
{{/each}}
```

进入 `each` 之后，context 会切换成当前正在遍历的列表项，因此我们可以直接用 `{{name}}` 获取当前项的 `name` 属性。

这时你肯定会好奇，怎么获取**当前项**呢？

Mustache 原版设计了 `.` 语法来获取当前 context，可是我觉得这不够自然，于是把 `.` 改成了 `this`，也就是说，上面这段模板可以换成下面这段：

```html
{{#each list}}
    {{this.name}}: {{this.age}}
{{/each}}
```

如果循环过程中要用到数组下标，可通过 `[array]:[index]` 语法实现，如下：

```
{{#each array:index}}
    ...
{{/each}}
```

一个很常见的需求是判断数组的最后一项，其实非常简单，加上 `if` 就行了。

```
{{#each array:index}}
    {{#if index === array.length - 1}}
        ...
    {{/if}}
{{/each}}
```

### 循环对象

在实现**循环数组**的时候，顺便实现了循环对象，因此语法同上。

```
{{#each object:key}}
    ...
{{/each}}
```

后来发现，这个特性还可以实现属性延展（虽然略冗长）。

```html
<Component{{#each props:key}} {{key}}="{{this}}"{{/each}} />
```

### 属性延展

虽然**循环对象**能变现实现延展操作符，但为了方便，我们实现了延展操作符，如下：

```html
<Component {{...props}} />
```

## 定义子模板

对于一些比较独立的模板，比如 `loading`，做成子模板在各个组件间共享，使用起来非常方便。

```
{{#partial name}}
    ...
{{/each}}
```

## 导入子模板

把定义好的子模板插入到需要的地方。

```
{{> name}}
```

## 过滤器

详情参考“**过滤器**”。

## 特殊变量

### $event

触发事件时，可用 `$event` 捕获当前事件对象，如下：

```html
<button on-click="submit($event)">
    Submit
</button>
```

> 调用方法如果没有参数，默认会把事件对象传进来，因此这里写与不写 `$event` 是一样的效果。
> 
> 加上这个特性主要是方便多个参数时修改 event 参数的位置

### $keypath

在模板的任何位置，可用 `$keypath` 获取当前 keypath，如下：

```html
{{#each array}}
    {{$keypath}}
{{/each}}
```

