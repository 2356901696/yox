计算属性与 Vue 的设计基本一致，如下：

```javascript
{
    computed: {
        // 如果是函数，就当做 getter
        a: function () {

        },

        b: {
            get: function () {

            },
            set: function (value) {

            }
        }
    }
}
```

## 缓存

计算属性的 getter 函数求值后，会缓存起来，只有当计算属性的依赖发生变化时，才会清除缓存。

如果不希望开启缓存，可关闭。

```javascript
{
    computed: {
        a: {
            cache: false,
            get: function () {

            }
        }
    }
}
```

## 依赖

计算属性的依赖是通过分析 `get` 函数得到的，当进入 `get` 函数之前，我们会准备一个数组，在 `get` 函数的执行过程中，所有的 `this.get(keypath)` 都会被当做是计算属性的依赖。


以具有全选功能的表格为例，全选表示表格的每一行都是选中状态。

这是计算属性非常典型的应用场景，代码如下：

HTML

```html
<label>
    <input type="checkbox" o-model="allChecked">
    全选
</label>
{{#each list}}
    <input type="checkbox" o-model="checked">
{{/each}}
```

JavaScript

```javascript
{
    data: {
        list: [
            { id: 1, checked: false },
            { id: 2, checked: false }
        ]
    },
    computed: {
        allChecked: {
            get: function () {
                var list = this.get('list');
                for (var i = 0, len = list.length; i < len; i++) {
                    if (!list[i].checked) {
                        return false;
                    }
                }
                return len > 0;
            },
            set: function (allChecked) {
                var list = this.get('list');
                var data = { };
                for (var i = 0, len = list.length; i < len; i++) {
                    data['list.' + i + '.checked'] = allChecked;
                }
                this.set(data);
            }
        }
    }
}
```

这段代码，乍看之下，似乎没有什么问题，其实它有两个问题：


与普通数据不同的是，计算属性不支持 watch，原因有两个：

1. 监听计算属性的变化，这个需求不是很常见
2. 实现不简单，我们不想为了一个罕见需求，徒增代码量

