计算属性与 Vue 的设计基本一致，如下：

```javascript
{
    computed: {
        // 如果是函数，就当做 getter
        a: function () {

        },

        b: {
            get: function () {

            },
            set: function (value) {

            }
        }
    }
}
```

## 缓存

计算属性的 getter 函数求值后，会缓存起来，只有当计算属性的依赖发生变化时，才会清除缓存。

如果不希望开启缓存，可关闭。

```javascript
{
    computed: {
        a: {
            cache: false,
            get: function () {

            }
        }
    }
}
```

## 依赖

计算属性的依赖是通过分析 `getter` 函数得到的，进入 `getter` 函数之前，我们会准备一个数组，在 `getter` 函数的执行过程中，所有的 `this.get(keypath)` 都会被当做计算属性的依赖，而只有这些依赖发生了变化，计算属性的缓存才会被清除。

理解这个原理非常重要，接下来我们以“全选”为例，这是计算属性非常典型的应用场景，代码如下：

HTML

```html
<label>
    <input type="checkbox" o-model="allChecked">
    全选
</label>
{{#each list}}
    <input type="checkbox" o-model="checked">
{{/each}}
```

JavaScript

```javascript
{
    data: {
        list: [
            { id: 1, checked: false },
            { id: 2, checked: false }
        ]
    },
    computed: {
        allChecked: {
            get: function () {
                var list = this.get('list');
                for (var i = 0, len = list.length; i < len; i++) {
                    if (!list[i].checked) {
                        return false;
                    }
                }
                return len > 0;
            },
            set: function (allChecked) {
                var list = this.get('list');
                var data = { };
                for (var i = 0, len = list.length; i < len; i++) {
                    data['list.' + i + '.checked'] = allChecked;
                }
                this.set(data);
            }
        }
    }
}
```

从 `allChecked` 的 `getter` 函数可以看出，它的依赖只有 `list`。

模板中每个单选的 `checkbox` 只会修改对应列表项的 `checked` 数据，注意，这里只是修改了列表项，而不是修改 `list`，因此 `allChecked` 的依赖并没有发生变化。

如果希望修改列表项的 `checked` 能影响 `allChecked`，有两种方式：

* 关闭缓存
* `getter` 函数明确获取真正的依赖，即列表项的 `checked`

关闭缓存前面已经提过，这种方式比较简单粗暴，见效快。

下面讲解第二种方式，稍微改造一下 `getter` 函数：

```javascript
{
    allChecked: {
        get: function () {
            var list = this.get('list');
            for (var i = 0, len = list.length; i < len; i++) {
                // 读取真正的依赖            
                if (!this.get('list.' + i + '.checked')) {
                    return false;
                }
            }
            return len > 0;
        }
    }
}
```

## Watch

与普通数据不同的是，计算属性不支持 watch。

判断变化需要有 `oldValue` 和 `newValue`，没有比较怎么判断变化呢？

对于 `oldValue` 来说，必须确保计算属性的 `getter` 函数执行过才会有值。这完全取决于业务逻辑，如果计算属性位于某个 `if` 中，谁也无法保证它一定会执行。

就算我们能确保有 `oldValue`，当计算属性的依赖发生变化时，意味着计算属性本身的值可能也变化了，但我们无法确定，所以要比较必须再执行一次 `getter` 函数，这次的执行仅仅是为了比较，并非为了真实的业务逻辑，更惨的是，开发者可能压根没监听这个计算属性的变化，因此，`newValue` 的取值和比较的过程看起来更像是在自娱自乐。

综上，恕我无能为力。
