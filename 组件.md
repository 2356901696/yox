组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。

在 Yox 中，父子组件的关系可以总结为 `props down, events up`。父组件通过 `props` 向下传递数据给子组件，子组件通过 `events` 给父组件发送消息。


## 自治

组件是自治的，这意味着它的依赖，需要外部传递进来。

```html
<Component prop="{{value}}" />
```

我们以 `attribute` 的方式，把数据传递到组件中。

> 和 Vue 不同的是，York 不对属性名做任何改动，模板里写的是什么，组件接收到的就是什么，不存在 `my-name` 转换成 `myName` 的情况。

如果属性比较多，还可以通过 `each` 变相实现属性延展，如下：

```html
<Component{{#each props:key}} {{key}}="{{this}}"{{/each}} />
```



## 组件引用

我们可以通过 `ref` 指令注册组件引用的名称，如下：

```html
<Component @ref="name" />
```

经过 `ref` 注册的组件实例会存在于父组件的 `$refs` 属性中，获取方式如下：

```javascript
this.$refs.name
```

## 事件

组件内部的事件，默认不冒泡，这意味着事件不会传递到组件外部。

如果想监听组件内部事件，可通过事件指令实现，如下：

```html
<Component on-xxx="yyy" />
```

```javascript
{
    yyy: function () {
        // 处理 yyy 事件
    }
}
```

如果组件内部触发的是冒泡事件，那么在目标组件的父级组件中，能自动监听，如下：

```javascript
// 目标组件触发一个冒泡事件
component.fire('xxx', true)
```

```javascript
// 父级组件
{
    events: {
        xxx: function () {
            // 处理 xxx 事件
        }
    }
}
```

