组件化开发是当前前端开发的趋势。在我使用 Vue 和 Ractive 的过程中，已经充分感受到它的强大。

## 结构

```javascript
{ 
    // 组件模板 
    template: '组件模板', 
    // 组件数据 
    data: function () { return {}; }, 
    // 计算属性 
    computed: {},
    // 监听事件
    events: {},
    // 监听数据变化
    watchers: {}, 
    // 子组件 
    components: {}, 
    // 子模板 
    partials: {}, 
    // 模板中使用的过滤器 
    filters: {}, 
    // 实例方法 
    methods: {},
    // 以下是生命周期钩子
    oninit: function,
    oncreate: function, 
    oncompile: function, 
    onattach: function, 
    onupdate: function,     
    ondetach: function
}```


## 自治

组件是自治的，这意味着它的依赖，需要外部传递进来。

```html
<Component prop="{{value}}" />
```

我们以类似 attribute 的方式，把数据传递到组件中。

> 和 Vue 不同的是，我们不会对属性名做任何改动，写的是什么，组件接收到的就是什么，不存在 `my-name` 转换成 `myName` 的情况。

如果属性比较多，还可以通过 `each` 变相实现属性延展，如下：

```html
<Component{{#each props:key}} {{key}}="{{this}}"{{/each}} />
```

## 传递的数据

传给子组件的数据，如果是基本类型，那么不会有什么问题。

如果是引用类型，这意味着子组件也可以修改数据，这里就抛出了一个问题，子组件是否可以修改数据，以及修改数据之后怎么通知父组件？



## 组件引用

我们可以通过 `ref` 指令注册组件引用的名称，如下：

```html
<Component @ref="name" />
```

经过 `ref` 注册的组件实例会存在于父组件的 `$refs` 属性中，获取方式如下：

```javascript
this.$refs.name
```

## 事件

组件内部的事件，默认不冒泡，这意味着事件不会传递到组件外部。

如果想监听组件内部事件，可通过事件指令实现，如下：

```html
<!-- 相当于把内部的 xxx 事件转换成 yyy 事件 -->
<Component on-xxx="yyy" />
```

```javascript
{
    yyy: function () {
        // 处理 yyy 事件
    }
}
```

如果组件内部触发的是冒泡事件，那么在目标组件的父级组件中，能自动监听，如下：

```javascript
// 目标组件触发一个冒泡事件
component.fire('xxx', true)
```

```javascript
// 父级组件
{
    events: {
        xxx: function () {
            // 处理 xxx 事件
        }
    }
}
```
## 一个根元素

为了保证组件有一个稳定的 DOM 元素（生命周期内一直存在），必须有一个根元素，如下：

```html
<div class="root">   
    {{#if username}}        
        hi, {{username}}!
    {{/if}}
</div>
```

不要写成如下形式，因为判断条件一旦变化，DOM 元素也变了，这样不利于后续很多工作的展开，比如事件委托。

```html
{{#if username}}    
    <div class="root">        
        hi, {{username}}!    
    </div>
{{else}}    
    <div class="root">        
        sign in.    
    </div>
{{/if}}
```
