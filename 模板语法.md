`Mustache` 具有以下特性：

* 语法简洁、美观
* 功能虽说不上强大，但也足够满足需求
* 上手成本低

但是 Mustache 语法并非完美，因此我们有针对性的做了一些改进，York 支持的完整语法如下。

### 插值

一对定界符（即 `{{` 和 `}}`）之间的内容是一个可以求值的**表达式**，表达式的值最终会经过**转义**渲染出来，因此它是**安全**的。

> 表达式有一章单独讲述，这里不作深入介绍

一般来说，表达式是一个变量，常见的形式如下：

```
{{name}}
```

或者是对象的属性、数组的下标，如下：

```
{{user.name}}
{{array[0]}}
```

或者是稍微复杂一些的表达式，如下：

```
{{name ? '你好' : '请登录'}}
```

### 不转义插值

插值的**非安全**版本，即渲染的内容和表达式的值完全一致，不做转义处理，常用于富文本的展示。

```
{{{expression}}}
```

> 注意：York 不支持 Mustache 的另一种不转义插值语法 `{{&expression}}`

### 判断


```
{{#if expression}}
    ...
{{else if expression}}
    ...
{{/if}}
```

如果对 `else if` 这种带空格的默认配置不满意，可以自行修改配置。

### 循环数组

很多模板引擎采用了 `item in list` 的语法，另一种比较常见的语法是 `each`，这两种风格我都长期使用过，个人感觉 `each` 是消耗脑细胞更少的一种方案。

```
{{#each array}}
    ...
{{/each}}
```

`each` 带来的一个特性是 data context 递进了一层，举个例子：

数据

```javascript
{
    list: [
        {
            name: 'new',
            age: 1
        },
        {
            name: 'york',
            age: 2
        }
    ]
}
```

模板

```html
{{#each list}}
    {{name}}: {{age}}
{{/each}}
```

进入 `each` 之后，context 会切换成当前正在遍历的列表项，因此我们可以直接用 `{{name}}` 获取当前项的 `name` 属性。

这时你肯定会好奇，怎么获取**当前项**呢？

Mustache 原本设计了 `.` 语法来获取当前 context，可是我觉得这不够自然，于是把 `.` 改成了 `this`，也就是说，上面这段模板可以改写成下面这样：


```html
{{#each list}}
    {{this.name}}: {{this.age}}
{{/each}}
```

如果循环过程中要用到数组下标，可通过 `[array]:[index]` 语法实现，如下：

```
{{#each array:index}}
    ...
{{/each}}
```

一个很常见的需求是判断数组最后一项，其实也非常简单，配合使用 `if` 就行了。

```
{{#each array:index}}
    {{#if index === array.length - 1}}
        ...
    {{/if}}
{{/each}}
```

### 循环对象

在实现**循环数组**的时候，顺便实现了循环对象，因此语法同上。

```
{{#each object:key}}
    ...
{{/each}}
```

后面发现，用这个特性做属性延展真是太妙了。

```html
<Component{{#each props:key}} {{key}}="{{this}}"{{/each}} />
```

### 定义子模板

对于一些比较独立的模板，比如 `loading`，做成子模板在各个组件间共享，使用起来非常方便。

```
{{#partial name}}
    ...
{{/each}}
```

### 导入子模板

把定义好的子模板插入到需要的地方。

```
{{> name}}
```

### 函数调用

York 没有实现 `{{expression|filter}}` 形式的过滤器，我们认为这种过滤器的写法其实是不够友好自然的。

js 调用函数的方式，前端同学非常了解，不需要文档解释更多，这样显然降低了学习成本。

```
{{formatDate(date)}}
```

更有意思的是，函数调用不仅能实现过滤器，还能支持更为强大的扩展（连函数都提供了，难道还有什么不能实现吗？）。

### 特殊变量

当触发事件时，可用 `$event` 表示当前事件对象，如下：

```html
<button @click="submit($event)">
    Submit
</button>
```

在模板的任何位置，可用 `$keypath` 获取当前 keypath，如下：

```html
{{#each array}}
    {{$keypath}}
{{/each}}
```

> keypath 有一章单独讲解