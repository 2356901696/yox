在众多模板引擎中，`Mustache` 可能是最有群众基础的，我们简单罗列几个它的家族成员：

* [Mustache](http://mustache.github.io/)
* [Hogan](http://twitter.github.io/hogan.js/)
* [Handlebars](http://handlebarsjs.com)

有这么多热衷于 `Mustache` 的轮子，可见其基因的优秀。

知乎上有一篇帖子 [Mustache 比传统的模板语言好在哪些地方？](https://www.zhihu.com/question/19882912)其中提的最多的一个关键词是“**简单**”。

是的，模板应该简单。模板引擎代表之一的 `Smarty` 堪称拥有非常强大的功能，可结果呢，模板却经常出现各种不可维护的代码，由此可见，再强大的模板引擎也无法很好的处理复杂的业务逻辑。

组件化带来了一种全新的开发思想，它主张把可控的复杂度分布到各个组件中，最后再把这些组件拼成一个页面。虽然整体的业务复杂度没有降低，代码质量却上了一个台阶，由此前端进入了新的时代。

简单是我们选择 `Mustache` 的原因，但我们不满足于此，我们希望让它更简单一些，下面将介绍 Yox 版本的 Mustache 语法。



## 循环数组

循环通常有两种设计风格，一种是 `item in array`，一种是 `each`。

我更偏向 `each`，因为它可以省略 `item`，减少命名的脑力消耗。

```
{{#each array}}
    ...
{{/each}}
```

有别于前面介绍的语法，`each` 会导致 context 递进一层，举个例子：

数据

```javascript
{
    list: [
        {
            name: 'Jake',
            age: 1
        },
        {
            name: 'John',
            age: 2
        }
    ]
}
```

模板

```html
{{#each list}}
    {{name}}: {{age}}
{{/each}}
```

进入 `each` 之后，context 会切换成当前正在遍历的列表项，因此我们可以直接用 `{{name}}` 获取当前项的 `name` 属性。

这时你肯定会好奇，怎么获取**当前项**呢？

Mustache 原版设计了 `.` 语法来获取当前 context，可是我们觉得不够自然，于是把 `.` 改成了 `this`，也就是说，上面这段模板也可以这样写：

```html
{{#each list}}
    {{this.name}}: {{this.age}}
{{/each}}
```

如果循环过程中要用到数组下标，可通过 `[array]:[index]` 语法实现，如下：

```
{{#each array:index}}
    ...
{{/each}}
```

一个很常见的需求是判断数组的最后一项，其实非常简单，加上 `if` 就行了。

```
{{#each array:index}}
    {{#if index === array.length - 1}}
        ...
    {{/if}}
{{/each}}
```

### 循环对象

在实现**循环数组**的时候，顺便实现了循环对象，因此语法同上。

```
{{#each object:key}}
    ...
{{/each}}
```

后来发现，这个特性还可以实现属性延展（略冗长）。

```html
<Component{{#each props:key}} {{key}}="{{this}}"{{/each}} />
```

### 属性延展

虽然**循环对象**能变现实现属性延展，但为了方便，我们还是专门实现了这个特性，如下：

```html
<Component {{...props}} />
```

我们还支持稍微复杂一些的表达式，如下：

```html
<Component {{... cond ? a : b}} />
```

## 定义子模板

对于一些比较独立的模板，比如 `loading`，做成子模板在各个组件间共享，使用起来非常方便。

```
{{#partial name}}
    ...
{{/each}}
```

## 导入子模板

把定义好的子模板插入到需要的地方。

```
{{> name}}
```

## 过滤器

详情参考“**过滤器**”。

## 特殊变量

### $event

触发事件时，可用 `$event` 捕获当前事件对象，如下：

```html
<button on-click="submit($event)">
    Submit
</button>
```

> 调用方法如果没有参数，默认会把事件对象传进来，因此这里写与不写 `$event` 是一样的。
> 
> 加上这个特性主要是方便多个参数时修改 event 参数的位置。

### $keypath

在模板的任何位置，可用 `$keypath` 获取当前 keypath，如下：

```html
{{#each array}}
    {{$keypath}}
{{/each}}
```

