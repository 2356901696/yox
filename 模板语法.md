在风格众多的模板引擎中，`Mustache` 是比较有群众基础的那个，简单罗列几个家族成员：

* Mustache 原版
* Hogan
* Handlebars

有这么多热衷于改造 `Mustache` 的轮子，可见其基因的优秀。

知乎上有一篇帖子 [Mustache 比传统的模板语言好在哪些地方？](https://www.zhihu.com/question/19882912)，提的最多的一个关键词是“**简单**”。

是的，模板不需要太复杂。模板引擎代表之一的 `Smarty` 堪称拥有非常强大的功能，可结果呢，却经常在模板中写出各种不可维护的代码。

组件化的到来证明了分而治之的思想，把可控的复杂度分布到各个组件中，最后再把这些组件拼成一个页面，由此前端进入了新的时代。

简单，是我们选择 Mustache 的原因，但我们不满足于此，我们希望继续提升它的简单，下面将介绍 York 版本的 Mustache 语法。

### 定界符

Mustache 的默认定界符是 `{{` 和 `}}`，我们认为这个设计非常好。

和很多框架不同的是，我们不支持自定义定界符，没有理由不选择最好的设计。

### 插值

定界符之间的内容通常是一个可以求值的**表达式**，它的值最终会经过**转义**再渲染出来，因此它是**安全**的。

一般来说，表达式可以是一个变量，如下：

```
{{name}}
```

或者是对象的属性、数组的下标，如下：

```
{{user.name}}
{{array[0]}}
```

或者是稍微复杂一些的表达式，如下：

```
{{name ? '你好' : '请登录'}}
```

### 不转义插值

插值的**非安全**版本，即渲染的内容和表达式的值完全一致，不做转义处理，常用于富文本的展示。

```
{{{expression}}}
```

> 注意：York 不支持 Mustache 的另一种不转义插值语法 `{{&expression}}`，其一为了统一用法，其二 `{{{` `}}}` 明显是最佳设计。


### 条件判断

`if` 或 `else if` 后面跟一个表达式，概念和 js 完全一致。

在 Mustache 的原版语法中，空数组会被认为是 `false`，这个设计简直反人类，因此在 York 的实现中，删除了这个特性。

```
{{#if expression}}
    ...
{{else if expression}}
    ...
{{/if}}
```

如果对 `else if` 这种带空格的默认配置不满意，可以自行修改配置，比如 `{{elseif expression}}` 或者 `{{elif expression}}`。

### 循环数组

在模板语法设计中，循环通常有两种风格，一种是 `item in array`，一种是 `each`，我更偏向 `each`，因为它可以省略 `item`，减少了命名的脑力消耗。

```
{{#each array}}
    ...
{{/each}}
```

有别于其他语法，`each` 会导致 context 递进一层，举个例子：

数据

```javascript
{
    list: [
        {
            name: 'Jake',
            age: 1
        },
        {
            name: 'John',
            age: 2
        }
    ]
}
```

模板

```html
{{#each list}}
    {{name}}: {{age}}
{{/each}}
```

进入 `each` 之后，context 会切换成当前正在遍历的列表项，因此我们可以直接用 `{{name}}` 获取当前项的 `name` 属性。

这时你肯定会好奇，怎么获取**当前项**呢？

Mustache 原版设计了 `.` 语法来获取当前 context，可是我觉得这不够自然，于是把 `.` 改成了 `this`，也就是说，上面这段模板可以换成下面这段：


```html
{{#each list}}
    {{this.name}}: {{this.age}}
{{/each}}
```

如果循环过程中要用到数组下标，可通过 `[array]:[index]` 语法实现，如下：

```
{{#each array:index}}
    ...
{{/each}}
```

一个很常见的需求是判断数组最后一项，其实也非常简单，配合使用 `if` 就行了。

```
{{#each array:index}}
    {{#if index === array.length - 1}}
        ...
    {{/if}}
{{/each}}
```

### 循环对象

在实现**循环数组**的时候，顺便实现了循环对象，因此语法同上。

```
{{#each object:key}}
    ...
{{/each}}
```

后面发现，用这个特性做属性延展真是太妙了。

```html
<Component{{#each props:key}} {{key}}="{{this}}"{{/each}} />
```

### 定义子模板

对于一些比较独立的模板，比如 `loading`，做成子模板在各个组件间共享，使用起来非常方便。

```
{{#partial name}}
    ...
{{/each}}
```

### 导入子模板

把定义好的子模板插入到需要的地方。

```
{{> name}}
```

### 过滤器

我们没有实现 `{{expression|filter}}` 形式的过滤器，因为不够简单。

举个例子，过滤器函数的第一个参数通常是需要过滤的值，如果只有一个参数，那么很自然就是 `{{expression|filter}}`。如果多余一个参数，语法就会变得很奇怪，比如 `{{expression|filter arg1 arg2}}`，有时我会想，arg1 和 arg2 之间到底是用空格呢，还是用逗号呢？老实讲，我到现在也没记住 Vue 到底是选择了哪一种。

York 的过滤器采用了**函数调用**的方式，前端同学对调用函数非常熟悉，不需要文档解释更多，这样明显降低了学习成本，比如格式化日期：

```
{{formatDate(date)}}
```

更有意义的是，函数调用不仅能实现过滤器，还能支持更为强大的扩展，因为这是函数嘛，嵌在表达式里的函数，你想怎么玩就怎么玩咯。

### 特殊变量

触发事件时，可用 `$event` 捕获当前事件对象，如下：

```html
<button on-click="submit($event)">
    Submit
</button>
```

在模板的任何位置，可用 `$keypath` 获取当前 keypath，如下：

```html
{{#each array}}
    {{$keypath}}
{{/each}}
```