在 Yox 的世界中，指令的定位是**扩展**。

没有指令，Yox 只是一个模板引擎，是指令给 Yox 带来了无限想象。

为了降低学习成本，同时为了减少文件体积，我们只内置了四个指令：

* **event**：监听 DOM 事件
* **model**：表单控件绑定
* **component**：组件的创建
* **ref**：组件的引用


## 识别

为了区分指令和属性（Attribute），我们提供了两个配置项。

```js
Yox.syntax.DIRECTIVE_PREFIX = 'o-';
Yox.syntax.DIRECTIVE_EVENT_PREFIX = 'on-';
```

也就是说，除了 `event` 指令，所有指令都以 `o-` 前缀开头。

> 如果你不喜欢 `o-` 风格的指令，可以自行修改配置。

## 扩展

如果内置指令不满足需求，可以自行扩展，只需遵循指令规范即可。

指令规范要求一个指令包含三种方法，编写时可按需实现：

* onattach：插入文档时触发
* onupdate: 元素更新时触发
* ondetach：从文档删除时触发

Yox 调用这些方法时，会传入一个对象类型的参数，格式如下：

```javascript
{
    el: 'DOM 元素',
    name: '指令名称',
    node: '指令对应的语法树节点',
    instance: '指令所属组件实例',
    directives: 'DOM 元素上绑定的其他指令，有时需要用到其他指令的数据'
}
```

## 注册

扩展的指令完成后，需要注册到 Yox。

对于通用性较强的指令，建议全局注册：

```js
Yox.directive('name', directive);
```

对于通用性不强的指令，建议本地注册：

```js
{
    directives: {
        name: directive
    }
}
```

## 示例

最后提供一个发送点击日志的示例。

```js
var directive = {
    onattach: function (options) {
        var value = options.node.getValue();
        var send = el.$log = function () {
            $.get('url', { value: value });
        };
        Yox.utils.native.on(options.el, 'click', send);
    },
    ondetach: function (options) {
        Yox.utils.native.off(options.el, 'click', options.el.$log);
        options.el.$log = null;
    }
};
Yox.directive('log', directive);
```

于是，你就可以在模板中使用这个 `log` 指令了。

```html
<div o-log="{id: 'xx'}"></div>
```