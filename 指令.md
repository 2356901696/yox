很多框架把指令描述的过于复杂，我觉得指令只是扮演了辅助的角色，为了降低复杂度，同时为了减少文件体积，York 只内置了如下 5 个指令：

* **event**：DOM 事件处理
* **model**：双向绑定
* **lazy**：配合双向绑定的 lazy（详情参考双向绑定）
* **component**：组件
* **ref**：配合组件

这 5 个指令可以分为三类：

* 事件处理：处理各种 DOM 事件
* 双向绑定：处理各种表单控件的双向同步行为
* 组件：生成组件树

## 事件处理

事件指令是一个很特殊的指令，其他指令通常只需要配置指令对应的一项数据，而事件指令，必须配置**两项**数据：

* 监听的事件类型
* 响应事件的行为

事件类型，我们采用了 `on-[type]` 的格式，用前缀 `on-` 和其他指令做出了区分。

事件行为，分为两种，一种是往外抛事件，一种是调用组件的方法。

### 抛事件

抛事件，我的理解是把底层的 DOM 事件转成有语义的事件，如下：

```html
<div on-click="submit"></div>
```

这里把 `click` 转成了 `submit`，它表达的是组件中产生了一个 `submit` 事件，因此我们可以通过配置 `events` 或手动调用 `on` 来监听，如下：

```javascript
{
    events: {
        submit: function (event) {
            // this 指向组件实例
            console.log(this, event);
        }
    },
    onattach: function () {
        // 除了配置 events，也可以这样手动监听
        this.on('submit', function (event) {
            // this 指向组件实例
            console.log(this, event);
        });
    }
}
```

为了使用方便，默认会把事件对象传进来。

此外，我们还能监听子组件的事件，如下：

```html
<Component on-submit="submit" />
```

```javascript
{
    events: {
        submit: function (data) {
            console.log(data);
        }
    }
}
```

这里的参数就不一定是事件对象了，主要看子组件是怎么触发事件的。

如果是 DOM 事件触发，那么这里接收到的参数依然是事件对象，如果是 `fire(type, data)` 触发，这里接收到的就是 `data` 了。

### 调用方法

为了方便，我们还支持调用组件方法。

```
<div on-click="method()"></div>
```

```javascript
{
    method: function (event) {
        console.log(this, event);
    }
}
```

同样，默认会把事件对象传进来，如果想定制参数，也可以用 `Mustache` 章节提到的特殊变量，如下：

```
<div on-click="method(name, $event, $keypath)"></div>
```

## 双向绑定

详情参考“双向绑定”章节。

## 组件

考虑到 HTML 标签通常是小写的，因此只要标签包含大写字母或出现连字符（-）就认为是组件，如下：

```html
<AppHeader />
```

或

```html
<app-header />
```

组件的标签名必须和注册到 `components` 中的 key 完全一致。

在组件中想获取子组件的实例，York 的设计和其他框架是一致的，通过 `ref` 指令，如下：

```html
<AppHeader @ref="header" />
```

这样在组件中，就能通过 `this.$refs.header` 获取该子组件的引用。
