很多框架把指令描述的过于复杂，其实指令只是扮演了辅助的角色，为了降低复杂度，同时为了减少文件体积，York 只内置了如下 5 个指令：

* **event**：DOM 事件处理
* **model**：双向绑定
* **lazy**：配合双向绑定的 lazy（详情参考双向绑定）
* **component**：组件
* **ref**：配合组件

这 5 个指令可以分为三类：

* 事件处理：处理各种 DOM 事件
* 双向绑定：处理各种表单控件的双向同步行为
* 组件：生成组件树

因为指令像属性（attribute）一样写在元素上，因此我们必须对指令和属性进行区分。

York 的做法是，除了 `event` 指令，所有指令都以 `@` 前缀开头。

## 事件处理

事件指令是一个很特殊的指令，其他指令通常只需要配置指令对应的一项数据，而事件指令，必须配置**两项**数据：

* 监听的事件类型
* 响应事件的行为

事件类型，我们采用了 `on-[type]` 的格式，用前缀 `on-` 和其他指令做出了区分。

详情参考“**事件**”章节。

## 双向绑定

详情参考“**双向绑定**”章节。

## 组件

考虑到 HTML 标签通常是小写的，因此 York 判断组件的方式如下：

* 标签包含大写字母
* 标签名称包含连字符

分别举例，如下：

```html
<AppHeader />
<app-header />
```

注意：组件的标签名必须和注册到 `components` 中的 key 完全一致。

### 子组件引用

在组件中获取子组件的引用，York 的设计和其他框架是一致的，如下：

```html
<AppHeader @ref="header" />
```

这样在组件中，就能通过 `this.$refs.header` 获取该子组件的引用。


## 扩展

如果内置指令不满足需求，可以自行扩展。

指令规范要求以下三种方法，编写时可按需实现：

* attach：插入文档时触发
* update: 元素更新时触发
* detach：从文档删除时触发

调用这些方法时，会传入一个对象参数，对象格式如下：

```javascript
{
    el: 'DOM 元素',
    name: '指令名称',
    node: '指令对应的语法树节点',
    instance: '指令所属组件实例',
    directives: 'DOM 元素上绑定的其他指令，有时需要用到其他指令的数据'
}
```



### 全局指令

```
York.directive('name', directive);
```

### 实例指令

```
{
    directives: {
        name: directive
    }
}
```
