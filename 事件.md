## 触发事件

我的理解是把底层的 DOM 事件转成有语义的事件，如下：

```html
<div on-click="submit"></div>
```

这里把 `click` 转成了 `submit`，它表达的是组件中产生了一个 `submit` 事件，因此我们可以通过配置 `events` 或手动调用 `on` 来监听，如下：


```javascript
{
    events: {
        submit: function (event) {
            // this 指向组件实例
            console.log(this, event);
        }
    },
    onattach: function () {
        // 除了配置 events，也可以这样手动监听
        this.on('submit', function (event) {
            // this 指向组件实例
            console.log(this, event);
        });
    }
}

```

为了使用方便，默认会把事件对象传进来。

此外，我们还能监听子组件的事件，如下：

```html
<Component on-submit="submit" />
```

```javascript
{
    events: {
        submit: function (data) {
            console.log(data);
        }
    }
}
```

这里的参数不一定是事件对象，这取决于子组件是怎么触发事件的。

如果是 DOM 事件触发，那么这里接收到的参数依然是事件对象，如果是 `fire(type, data)` 触发，这里接收到的就是 `data` 了。

## 调用方法

为了方便，我们还支持调用组件方法。

```html
<div on-click="submit()"></div>
```

```javascript
{
    submit: function (event) {
        console.log(this, event);
    }
}
```

同样，默认会把事件对象传进来，如果想定制参数，也可以用 `**Mustache**` 章节提到的特殊变量，如下：

```html
<div on-click="submit(name, $event, $keypath)"></div>
```

## 事件冒泡

触发事件默认只在当前组件内部活跃，这主要是想控制事件的影响范围。

但有时我们希望事件能够一直冒泡到根组件，这就需要手动调用 `fire` 方法，并设置 `bubble` 参数为 `true`。

```javascript
component.fire(type, data, true); // 事件需要携带数据
component.fire(type, true);
```

## 事件停止广播

和 jQuery 相同，事件处理函数只要返回 `false`，就会阻止后续的 handler 执行。